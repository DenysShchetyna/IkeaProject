<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.2.0">
<procedure name="main">
<interface/>
<body>
<c>****Function:                        Function_DrawingReader****</c>
<c>****Changelog                        Version 1.0 – 2020-06-25 Palkovic J.</c>
<c>****                                 – Initial Version</c>
<c>****                                 Version 2.0 – 2020-06-29 Kacmarik J.</c>
<c>****                                 - Added functionality for shift contours to positiv area</c>
<c>****                                 - measurement Witdh, Lenght and Thickness of the board in mm</c>
<c>****                                 Version 3.0 – 2020-06-30 Palkovic J.</c>
<c>****                                 - Changed Width measurement for cutted boards</c>
<c>****                                 Version 4.0 – 2020-07-02 Kacmarik J.</c>
<c>****                                 - Added functionality for add circles to regions</c>
<c>****                                 Version 5.0 – 2020-07-02 Kacmarik J.</c>
<c>****                                 - Added functionality shift WCS to [0, 0] for each region and circles tuple</c>
<c>****                                 Version 6.0 – 2020-07-03 Palkovic J.</c>
<c>****                                 - Created procedures Function_MeasurementCirclesCoordinations and Function_RoiGenerator</c>
<c>****Description:                     function for read parameters from .dxf file</c>
<c>****Inputs:                          h_strDxfPath</c>
<c>****Outputs:                         h_intSurfaceTypeFromDrawing</c>
<c>****                                 h_realRecipeLengthOfBoardMm</c>
<c>****                                 h_realRecipeWitdhOfBoardMm</c>
<c>****                                 h_realRecipeThickessOfBoardMm</c>
<c>****                                 h_real_arrXPositionMmRightFromDrawing</c>
<c>****                                 h_real_arrYPositionMmRightFromDrawing</c>
<c>****                                 h_real_arrDiameterMmRightFromDrawing</c>
<c>****                                 h_real_arrXPositionMmFrontFromDrawing</c>
<c>****                                 h_real_arrYPositionMmFrontFromDrawing</c>
<c>****                                 h_real_arrDiameterMmFrontFromDrawing</c>
<c>****                                 h_real_arrXPositionMmBottomFromDrawing</c>
<c>****                                 h_real_arrYPositionMmBottomFromDrawing</c>
<c>****                                 h_real_arrDiameterMmBottomFromDrawing</c>
<c>****                                 h_real_arrXPositionMmBackFromDrawing</c>
<c>****                                 h_real_arrYPositionMmBackFromDrawing</c>
<c>****                                 h_real_arrDiameterMmBackFromDrawing</c>
<c>****                                 h_real_arrXPositionMmTopFromDrawing</c>
<c>****                                 h_real_arrYPositionMmTopFromDrawing</c>
<c>****                                 h_real_arrDiameterMmTopFromDrawing</c>
<c>****                                 h_real_arrXPositionMmLeftFromDrawing</c>
<c>****                                 h_real_arrYPositionMmLeftFromDrawing</c>
<c>****                                 h_real_arrDiameterMmLeftFromDrawing</c>
<c>****                                 h_reg_arrRoiMmTopPartSmallHolesForLsCameras</c>
<c>****                                 h_reg_arrRoiMmTopPartLargeHolesForArCameras</c>
<c>****                                 h_reg_arrRoiMmBottomPartSmallHolesForLsCameras</c>
<c>****                                 h_reg_arrRoiMmBottomPartLargeHolesForArCameras</c>
<c>****                                 h_reg_arrRoiMmLeftPartHolesForLsCameras</c>
<c>****                                 h_reg_arrRoiMmRightPartHolesForLsCameras</c>
<c>****                                 h_reg_arrRoiMmFrontPartHolesForArCameras</c>
<c>****                                 h_reg_arrRoiMmBackPartHolesForArCameras</c>
<c>**Start of function</c>
<c></c>
<c></c>
<l>h_strDxfPath := 'M:/Moje_Dokumenty/A0670_ Holes_ Inspection_System/DXF/vykresy_zo_zadania/zdruzene_vykresy'</l>
<l>h_strDxfPath := 'C:/Trifid/IKEA/Vykresy'</l>
<c></c>
<l>dev_update_on ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 512, 512, 'black', WindowHandle)</l>
<c></c>
<c>* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l>gen_image_const (Image, 'byte', 3000, 3000)</l>
<c></c>
<c>* Kontury su posunute do zapornej oblasti. Preto je potrebne ich precitat a postupne posunut do kladnej oblasti</c>
<c>* Najlepsie by bolo, keby nam nedavali posunute kontury. Bod [0, 0] teraz je na pozicii, ktora urcite nie je stredom suradnicovej sustavy</c>
<c>*</c>
<c>* Offset pre posun kontur do kladnej oblasti</c>
<l>OffsetRowPix := 750</l>
<l>OffsetColPix := 750</l>
<c>*</c>
<c>*NACITANIE VYKRESU</c>
<l>*read_contour_xld_dxf (Contours, h_strDxfPath, [], [], DxfStatusCont)</l>
<c>*/</c>
<l>list_files (h_strDxfPath, ['files','follow_links'], ContourFiles)</l>
<l>tuple_regexp_select (ContourFiles, ['\\.(dxf)$','ignore_case'], ContourFiles)</l>
<l>for I := 0 to |ContourFiles| - 1 by 1</l>
<l>    dev_clear_window()</l>
<l>    read_contour_xld_dxf(Contours, ContourFiles[I], [], [], DxfStatus)</l>
<c>*/</c>
<c>*TYP MATERIALU Z NAZVU</c>
<l>*parse_filename(h_strDxfPath, BaseName, Extension, Directory)    </l>
<l>parse_filename(ContourFiles[I], BaseName, Extension, Directory)</l>
<l>tuple_substr(BaseName, 5, 8, h_intSurfaceTypeFromDrawing)   </l>
<c>*    </c>
<c>*POSUNUTIE KONTUR</c>
<l>gen_empty_obj (NewPositionContour)</l>
<l>count_obj (Contours, Number)</l>
<l>for Index := 1 to Number by 1</l>
<c>    * Po ciastovych konturach precitanie a posunutie a nasledne poskladanie na novej pozicii, ktora je uz v kladnej oblasti </c>
<l>    select_obj (Contours, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, Row, Col) </l>
<l>    RowNew := Row + OffsetRowPix</l>
<l>    ColNew := Col + OffsetColPix</l>
<l>    gen_contour_polygon_xld (Contour, RowNew, ColNew)</l>
<l>    concat_obj (NewPositionContour, Contour, NewPositionContour)    </l>
<l>endfor</l>
<c>* Ukazka posunutej Contour </c>
<l>dev_display (Image)</l>
<l>dev_display (NewPositionContour)</l>
<c>*</c>
<l>stop()</l>
<c>* Verim, ze raz budu kontury len v kladnej oblasti a preto do premennej Contours zapiseme NewPositionContour</c>
<l>Contours := NewPositionContour</l>
<c>*</c>
<l>*segment_contours_xld (Contours, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<c>* Ked bol SmoothCont = 5, tak nenajde najmensie otvory </c>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines_circles', 1, 2, 2)</l>
<l>count_obj (ContoursSplit, Number1)</l>
<l>gen_empty_obj (ContourOnlyFromLines)</l>
<l>gen_empty_obj (ContourOnlyFromCircles)</l>
<l>for Index1 := 1 to Number1 by 1</l>
<l>    select_obj (ContoursSplit, ObjectSelected1, Index1)</l>
<l>    get_contour_global_attrib_xld (ObjectSelected1, 'cont_approx', Attrib)</l>
<l>    if (Attrib == 1)</l>
<c>        * Ak je tato cast kruznica, tak ju nepouzijeme na vytvorenie novej kontury </c>
<c>        * ale pouzijeme ju na vytvorenie Circle kontur   </c>
<l>        concat_obj (ContourOnlyFromCircles, ObjectSelected1, ContourOnlyFromCircles)         </l>
<l>    else</l>
<c>        * Ak je tato cast line, tak ju pouzijeme na vytvorenie novej kontury</c>
<l>        concat_obj (ContourOnlyFromLines, ObjectSelected1, ContourOnlyFromLines)</l>
<l>    endif    </l>
<l>endfor</l>
<c>* Ukazka line Contour </c>
<l>dev_display (Image)</l>
<l>dev_display (ContourOnlyFromLines)</l>
<l>dev_display (Image)</l>
<l>dev_display (ContourOnlyFromCircles)</l>
<c>*</c>
<l>stop()</l>
<c>*MERANIE DLZKY, SIRKY a HRUBKY DOSKY</c>
<c>* Z contury, ktora je poskladana uz len z lines vytvorime regiony a odmeriame ich area</c>
<l>gen_region_contour_xld (ContourOnlyFromLines, Region, 'filled')</l>
<l>union1 (Region, RegionUnion)</l>
<l>connection (RegionUnion, ConnectedRegions)</l>
<l>area_center (ConnectedRegions, AreaConnectedRegions, RowConnectedRegions, ColumnConnectedRegions)</l>
<c>* Ukazka ConnectedRegions</c>
<l>dev_display (Image)</l>
<l>dev_display (ConnectedRegions)</l>
<c>*</c>
<c>* Vyberieme Regiony vacsie nez limit </c>
<l>tuple_sort_index (AreaConnectedRegions, IndicesAreaConnectedRegions)</l>
<l>tuple_inverse (IndicesAreaConnectedRegions, InvertedIndicesAreaConnectedRegions)</l>
<c>* Pocet regionov moze byt len 6 (ak je nerozrezana doska), alebo 10 (ak je rozrezana doska)</c>
<l>LimitMinArea := 200</l>
<l>Area_6  := AreaConnectedRegions[InvertedIndicesAreaConnectedRegions[6-1]]</l>
<l>Area_10 := AreaConnectedRegions[InvertedIndicesAreaConnectedRegions[10-1]]</l>
<l>if (Area_10 &gt; LimitMinArea)</l>
<l>    NumRegions := 10</l>
<l>else</l>
<l>    NumRegions := 6</l>
<l>endif</l>
<c>*</c>
<c>* Vyberieme len prvych NumRegions a tieto budu uz ciste, bez otvorov, bez krizikov</c>
<l>gen_empty_obj (RegionFromChart)</l>
<l>for Index2 := 0 to NumRegions-1 by 1</l>
<l>   select_obj (ConnectedRegions, PartialRegionP, InvertedIndicesAreaConnectedRegions[Index2]+1)</l>
<c>        * Ukazka postupne parcialne regiony </c>
<l>        dev_display (Image)</l>
<l>        dev_display (PartialRegionP)   </l>
<l>   smallest_rectangle2 (PartialRegionP, Row3, Column3, Phi, Length1, Length2)</l>
<l>   gen_rectangle2 (PartialRegion, Row3, Column3, Phi, Length1, Length2)        </l>
<l>   concat_obj (RegionFromChart, PartialRegion, RegionFromChart)   </l>
<l>endfor</l>
<c>* Ukazka RegionFromChart</c>
<l>dev_set_draw ('fill')</l>
<l>dev_display (Image)</l>
<l>dev_display (RegionFromChart)</l>
<c>*</c>
<l>dev_set_draw ('margin')</l>
<l>dev_display (Image)</l>
<l>dev_display (RegionFromChart)</l>
<c>*</c>
<c></c>
<l>area_center (RegionFromChart, Area2, Row2, Column2)</l>
<c>* Ukazka poloh stredov regionov </c>
<l>gen_cross_contour_xld (Cross, Row2, Column2, 86, 0.785398)</l>
<c>*</c>
<c>* Vyber jednotlivych regionov podla stran na doske</c>
<l>sort_region(RegionFromChart, SortedRegions, 'upper_left', 'true', 'row')</l>
<l>if (NumRegions = 6)</l>
<l>    select_obj(SortedRegions, RegionRight, 1)</l>
<l>    select_obj(SortedRegions, RegionFront, 2)</l>
<l>    select_obj(SortedRegions, RegionBottom, 3)</l>
<l>    select_obj(SortedRegions, RegionBack, 4)</l>
<l>    select_obj(SortedRegions, RegionTop, 5)</l>
<l>    select_obj(SortedRegions, RegionLeft, 6)</l>
<l>elseif (NumRegions = 10) </l>
<l>    select_obj(SortedRegions, RegionRight, 1)</l>
<l>    select_obj(SortedRegions, RegionFrontPart1, 2)</l>
<l>    select_obj(SortedRegions, RegionBottomPart1, 3)</l>
<l>    select_obj(SortedRegions, RegionBackPart1, 4)</l>
<l>    select_obj(SortedRegions, RegionTopPart1, 5) </l>
<l>    select_obj(SortedRegions, RegionFrontPart2, 6)</l>
<l>    select_obj(SortedRegions, RegionBottomPart2, 7)</l>
<l>    select_obj(SortedRegions, RegionBackPart2, 8)</l>
<l>    select_obj(SortedRegions, RegionTopPart2, 9)</l>
<l>    select_obj(SortedRegions, RegionLeft, 10)</l>
<c>    *</c>
<c>    * Spojenie  rozrezanej dosky</c>
<l>    smallest_rectangle1(RegionBackPart1, Row11, Column11, Row21, Column21)</l>
<l>    smallest_rectangle1(RegionBackPart2, Row12, Column12, Row22, Column22)</l>
<l>    gen_rectangle1(RegionBack, Row11, Column11, Row22, Column22)</l>
<c>    *</c>
<l>    smallest_rectangle1(RegionBottomPart1, Row11, Column11, Row21, Column21)</l>
<l>    smallest_rectangle1(RegionBottomPart2, Row12, Column12, Row22, Column22)</l>
<l>    gen_rectangle1(RegionBottom, Row11, Column11, Row22, Column22)</l>
<c>    *</c>
<l>    smallest_rectangle1(RegionFrontPart1, Row11, Column11, Row21, Column21)</l>
<l>    smallest_rectangle1(RegionFrontPart2, Row12, Column12, Row22, Column22)</l>
<l>    gen_rectangle1(RegionFront, Row11, Column11, Row22, Column22)</l>
<c>    *</c>
<l>    smallest_rectangle1(RegionTopPart1, Row11, Column11, Row21, Column21)</l>
<l>    smallest_rectangle1(RegionTopPart2, Row12, Column12, Row22, Column22)</l>
<l>    gen_rectangle1(RegionTop, Row11, Column11, Row22, Column22)</l>
<l>endif</l>
<c>*</c>
<c>* Dlzka dosky</c>
<l>smallest_rectangle2 (RegionLeft, Row1, Column1, Phi1, Length11, Length21)</l>
<l>h_realRecipeLengthOfBoardMm := max2(Length11, Length21) * 2 </l>
<c>* Sirka dosky</c>
<l>smallest_rectangle2 (RegionBack, Row1, Column1, Phi1, Length111, Length211)</l>
<l>h_realRecipeWitdhOfBoardMm := max2(Length111, Length211) * 2 </l>
<c>* Hrubka dosky</c>
<l>h_realRecipeThickessOfBoardMm := min2(Length111, Length211) * 2</l>
<c></c>
<l>dev_display (Image)</l>
<l>dev_display (RegionFromChart)</l>
<c></c>
<l>dev_disp_text ('Recipe_WitdhOfBoardMm = ' + h_realRecipeWitdhOfBoardMm + ' mm', 'window', 300, 0, 'black', [], [])</l>
<l>dev_disp_text ('Recipe_LengthOfBoardMm = ' + h_realRecipeLengthOfBoardMm + ' mm', 'window', 350, 0, 'black', [], [])</l>
<l>dev_disp_text ('Recipe_ThicknessOfBoardMm = ' + h_realRecipeThickessOfBoardMm + ' mm', 'window', 400, 0, 'black', [], [])</l>
<l>gen_cross_contour_xld (Cross, Row2, Column2, 86, 0.785398)</l>
<l>stop()</l>
<c></c>
<c>*UMIESTNENIE OTVOROV DO JEDNOTLIVYCH REGIONOV</c>
<c>    * Pre kazdy region je vytvorene pole kontur kruzkov. Napr. pre RegionRight je CirclesInRegionRight. Teda spravne pre h_regRegionRight je h_con_arrCirclesInRegionRight</c>
<l>    Function_AssigningCirclesToRegions (ContourOnlyFromCircles, RegionRight, RegionFront, RegionBottom, RegionBack, RegionTop, RegionLeft, CirclesInRegionRight, CirclesInRegionFront, CirclesInRegionBottom, CirclesInRegionBack, CirclesInRegionTop, CirclesInRegionLeft, h_mix_arrException)</l>
<l>*     dev_display (Image)</l>
<l>*     dev_display (CirclesInRegionBottom)  </l>
<l>stop()</l>
<c></c>
<c>    * toto je uzitocne pouzit aby sme vedeli zobrazovat pri ladena, ale aby to nevadilo v C# </c>
<l>h_intOfflineImageProcessing := 1</l>
<c>*POSUNUTIE SURADNICOVEJ SUSTAVY PRE JEDNOTLIVE POHLADY OD [0, 0] </c>
<c>*POSUNUTIE SURADNIC OTVOROV DO JEDNOTLIVYCH POHLADOV OD [0, 0] </c>
<c>    * Kazdy region a pole kruznic je umiestneny od [0, 0], tak ako to vidi kamera. (1pix == 1mm)</c>
<l>    Function_PlacementRegionsAndCirclesToZeroPosition (RegionRight, CirclesInRegionRight, RegionFront, CirclesInRegionFront, RegionBottom, CirclesInRegionBottom, RegionBack, CirclesInRegionBack, RegionTop, CirclesInRegionTop, RegionLeft, CirclesInRegionLeft, h_regRegionRightMmInZeroPosition, h_con_arrCirclesInRegionRightMmInZeroPosition, h_regRegionFrontMmInZeroPosition, h_con_arrCirclesInRegionFrontMmInZeroPosition, h_regRegionBottomMmInZeroPosition, h_con_arrCirclesInRegionBottomMmInZeroPosition, h_regRegionBackMmInZeroPosition, h_con_arrCirclesInRegionBackMmInZeroPosition, h_regRegionTopMmInZeroPosition, h_con_arrCirclesInRegionTopMmInZeroPosition, h_regRegionLeftMmInZeroPosition, h_con_arrCirclesInRegionLeftMmInZeroPosition, h_intOfflineImageProcessing, h_mix_arrException)   </l>
<l>stop()</l>
<c></c>
<c>*MERANIE OTVOROV</c>
<l>    Function_MeasurementCirclesCoordinations (h_con_arrCirclesInRegionRightMmInZeroPosition, h_con_arrCirclesInRegionFrontMmInZeroPosition, h_con_arrCirclesInRegionBottomMmInZeroPosition, h_con_arrCirclesInRegionBackMmInZeroPosition, h_con_arrCirclesInRegionTopMmInZeroPosition, h_con_arrCirclesInRegionLeftMmInZeroPosition, h_real_arrXPositionMmRightFromDrawing, h_real_arrYPositionMmRightFromDrawing, h_real_arrDiameterMmRightFromDrawing, h_real_arrXPositionMmFrontFromDrawing, h_real_arrYPositionMmFrontFromDrawing, h_real_arrDiameterMmFrontFromDrawing, h_real_arrXPositionMmBottomFromDrawing, h_real_arrYPositionMmBottomFromDrawing, h_real_arrDiameterMmBottomFromDrawing, h_real_arrXPositionMmBackFromDrawing, h_real_arrYPositionMmBackFromDrawing, h_real_arrDiameterMmBackFromDrawing, h_real_arrXPositionMmTopFromDrawing, h_real_arrYPositionMmTopFromDrawing, h_real_arrDiameterMmTopFromDrawing, h_real_arrXPositionMmLeftFromDrawing, h_real_arrYPositionMmLeftFromDrawing, h_real_arrDiameterMmLeftFromDrawing)</l>
<l>stop()</l>
<c></c>
<c>*VYTVORENIE VYHLADAVACICH REGIONOV PRE JEDNOTLIVE POHLADY </c>
<l>    Function_RoiGenerator (CirclesInRegionRight, CirclesInRegionFront, CirclesInRegionBottom, CirclesInRegionBack, CirclesInRegionTop, CirclesInRegionLeft, h_reg_arrRoiMmTopPartSmallHolesForLsCameras, h_reg_arrRoiMmTopPartLargeHolesForArCameras, h_reg_arrRoiMmBottomPartSmallHolesForLsCameras, h_reg_arrRoiMmBottomPartLargeHolesForArCameras, h_reg_arrRoiMmLeftPartHolesForLsCameras, h_reg_arrRoiMmRightPartHolesForLsCameras, h_reg_arrRoiMmFrontPartHolesForArCameras, h_reg_arrRoiMmBackPartHolesForArCameras, h_real_arrXPositionMmRightFromDrawing, h_real_arrYPositionMmRightFromDrawing, h_real_arrDiameterMmRightFromDrawing, h_real_arrXPositionMmFrontFromDrawing, h_real_arrYPositionMmFrontFromDrawing, h_real_arrDiameterMmFrontFromDrawing, h_real_arrXPositionMmBottomFromDrawing, h_real_arrYPositionMmBottomFromDrawing, h_real_arrDiameterMmBottomFromDrawing, h_real_arrXPositionMmBackFromDrawing, h_real_arrYPositionMmBackFromDrawing, h_real_arrDiameterMmBackFromDrawing, h_real_arrXPositionMmTopFromDrawing, h_real_arrYPositionMmTopFromDrawing, h_real_arrDiameterMmTopFromDrawing, h_real_arrXPositionMmLeftFromDrawing, h_real_arrYPositionMmLeftFromDrawing, h_real_arrDiameterMmLeftFromDrawing)</l>
<l>stop()</l>
<c></c>
<c>*END</c>
<c>*/</c>
<l>endfor</l>
<c>*/</c>
<c></c>
<c>*TODO - osetrit vizualizaciu a stopky pri spusteni zo C#</c>
<c>*TODO - vytvorit proceduru, na vstupe bude priamo cesta na konkretny vykres, vymazat list_files</c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="Function_AssigningCirclesToRegions">
<interface>
<io>
<par name="h_con_arrContourOnlyFromCircles" base_type="iconic" dimension="0"/>
<par name="h_regRegionRight" base_type="iconic" dimension="0"/>
<par name="h_regRegionFront" base_type="iconic" dimension="0"/>
<par name="h_regRegionBottom" base_type="iconic" dimension="0"/>
<par name="h_regRegionBack" base_type="iconic" dimension="0"/>
<par name="h_regRegionTop" base_type="iconic" dimension="0"/>
<par name="h_regRegionLeft" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="h_con_arrCirclesInRegionRight" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionFront" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBottom" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBack" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionTop" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionLeft" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="h_mix_arrException" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    gen_empty_obj (h_con_arrCirclesInRegionRight)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionFront)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionBottom)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionBack)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionTop)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionLeft)</l>
<l>try</l>
<c>    *</c>
<l>        count_obj (h_con_arrContourOnlyFromCircles, NumberCircles)</l>
<c>    *RegionRight</c>
<l>        for IndexCircles := 1 to NumberCircles by 1</l>
<l>            select_obj (h_con_arrContourOnlyFromCircles, ObjectSelectedCircle, IndexCircles)</l>
<l>            fit_circle_contour_xld (ObjectSelectedCircle, 'algebraic', -1, 0, 0, 3, 2, RowCenterCircle, ColumnCenterCircle, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>            area_center_points_xld (ObjectSelectedCircle, Area3, RowCircle, ColumnCircle)</l>
<l>            test_region_point (h_regRegionRight, RowCircle, ColumnCircle, IsInside)</l>
<l>            if (IsInside)</l>
<l>                concat_obj (h_con_arrCirclesInRegionRight, ObjectSelectedCircle, h_con_arrCirclesInRegionRight)</l>
<l>            endif</l>
<l>        endfor</l>
<c>    *RegionFront</c>
<l>        for IndexCircles := 1 to NumberCircles by 1</l>
<l>            select_obj (h_con_arrContourOnlyFromCircles, ObjectSelectedCircle, IndexCircles)</l>
<l>            fit_circle_contour_xld (ObjectSelectedCircle, 'algebraic', -1, 0, 0, 3, 2, RowCenterCircle, ColumnCenterCircle, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>            area_center_points_xld (ObjectSelectedCircle, Area3, RowCircle, ColumnCircle)</l>
<l>            test_region_point (h_regRegionFront, RowCircle, ColumnCircle, IsInside)</l>
<l>            if (IsInside)</l>
<l>                concat_obj (h_con_arrCirclesInRegionFront, ObjectSelectedCircle, h_con_arrCirclesInRegionFront)</l>
<l>            endif</l>
<l>        endfor    </l>
<c>    *RegionBottom</c>
<l>        for IndexCircles := 1 to NumberCircles by 1</l>
<l>            select_obj (h_con_arrContourOnlyFromCircles, ObjectSelectedCircle, IndexCircles)</l>
<l>            fit_circle_contour_xld (ObjectSelectedCircle, 'algebraic', -1, 0, 0, 3, 2, RowCenterCircle, ColumnCenterCircle, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>            area_center_points_xld (ObjectSelectedCircle, Area3, RowCircle, ColumnCircle)</l>
<l>            test_region_point (h_regRegionBottom, RowCircle, ColumnCircle, IsInside)</l>
<l>            if (IsInside)</l>
<l>                concat_obj (h_con_arrCirclesInRegionBottom, ObjectSelectedCircle, h_con_arrCirclesInRegionBottom)</l>
<l>            endif</l>
<l>        endfor    </l>
<c>    *RegionBack</c>
<l>        for IndexCircles := 1 to NumberCircles by 1</l>
<l>            select_obj (h_con_arrContourOnlyFromCircles, ObjectSelectedCircle, IndexCircles)</l>
<l>            fit_circle_contour_xld (ObjectSelectedCircle, 'algebraic', -1, 0, 0, 3, 2, RowCenterCircle, ColumnCenterCircle, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>            area_center_points_xld (ObjectSelectedCircle, Area3, RowCircle, ColumnCircle)</l>
<l>            test_region_point (h_regRegionBack, RowCircle, ColumnCircle, IsInside)</l>
<l>            if (IsInside)</l>
<l>                concat_obj (h_con_arrCirclesInRegionBack, ObjectSelectedCircle, h_con_arrCirclesInRegionBack)</l>
<l>            endif</l>
<l>        endfor     </l>
<c>    *RegionTop</c>
<l>        for IndexCircles := 1 to NumberCircles by 1</l>
<l>            select_obj (h_con_arrContourOnlyFromCircles, ObjectSelectedCircle, IndexCircles)</l>
<l>            fit_circle_contour_xld (ObjectSelectedCircle, 'algebraic', -1, 0, 0, 3, 2, RowCenterCircle, ColumnCenterCircle, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>            area_center_points_xld (ObjectSelectedCircle, Area3, RowCircle, ColumnCircle)</l>
<l>            test_region_point (h_regRegionTop, RowCircle, ColumnCircle, IsInside)</l>
<l>            if (IsInside)</l>
<l>                concat_obj (h_con_arrCirclesInRegionTop, ObjectSelectedCircle, h_con_arrCirclesInRegionTop)</l>
<l>            endif</l>
<l>        endfor      </l>
<c>    *RegionLeft</c>
<l>        for IndexCircles := 1 to NumberCircles by 1</l>
<l>            select_obj (h_con_arrContourOnlyFromCircles, ObjectSelectedCircle, IndexCircles)</l>
<l>            fit_circle_contour_xld (ObjectSelectedCircle, 'algebraic', -1, 0, 0, 3, 2, RowCenterCircle, ColumnCenterCircle, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>            area_center_points_xld (ObjectSelectedCircle, Area3, RowCircle, ColumnCircle)</l>
<l>            test_region_point (h_regRegionLeft, RowCircle, ColumnCircle, IsInside)</l>
<l>            if (IsInside)</l>
<l>                concat_obj (h_con_arrCirclesInRegionLeft, ObjectSelectedCircle, h_con_arrCirclesInRegionLeft)</l>
<l>            endif</l>
<l>        endfor </l>
<l>catch (h_mix_arrException)</l>
<c>    </c>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="Function_AssigningCirclesToRegions">
<parameters>
<parameter id="h_con_arrCirclesInRegionBack"/>
<parameter id="h_con_arrCirclesInRegionBottom"/>
<parameter id="h_con_arrCirclesInRegionFront"/>
<parameter id="h_con_arrCirclesInRegionLeft"/>
<parameter id="h_con_arrCirclesInRegionRight"/>
<parameter id="h_con_arrCirclesInRegionTop"/>
<parameter id="h_con_arrContourOnlyFromCircles"/>
<parameter id="h_mix_arrException"/>
<parameter id="h_regRegionBack"/>
<parameter id="h_regRegionBottom"/>
<parameter id="h_regRegionFront"/>
<parameter id="h_regRegionLeft"/>
<parameter id="h_regRegionRight"/>
<parameter id="h_regRegionTop"/>
</parameters>
</docu>
</procedure>
<procedure name="Function_A0670_PlacementRegionsToZeroPosition">
<interface>
<io>
<par name="h_regRegionRight" base_type="iconic" dimension="0"/>
<par name="h_regRegionFront" base_type="iconic" dimension="0"/>
<par name="h_regRegionBottom" base_type="iconic" dimension="0"/>
<par name="h_regRegionBack" base_type="iconic" dimension="0"/>
<par name="h_regRegionTop" base_type="iconic" dimension="0"/>
<par name="h_regRegionLeft" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="h_regRegionRightMmFromZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionFrontMmFromZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionBottomMmFromZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionBackMmFromZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionTopMmFromZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionLeftMmFromZeroPosition" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="h_mix_arrException" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>    gen_empty_obj (h_regRegionRightMmFromZeroPosition)</l>
<l>    gen_empty_obj (h_regRegionFrontMmFromZeroPosition)</l>
<l>    gen_empty_obj (h_regRegionBottomMmFromZeroPosition)</l>
<l>    gen_empty_obj (h_regRegionBackMmFromZeroPosition)</l>
<l>    gen_empty_obj (h_regRegionTopMmFromZeroPosition)</l>
<l>    gen_empty_obj (h_regRegionLeftMmFromZeroPosition)</l>
<l>try</l>
<c>    *</c>
<l>        smallest_rectangle1 (h_regRegionRight, Row1Reg, Column1Reg, Row2Reg, Column2Reg)</l>
<l>    gen_rectangle1 (h_regRegionRightMmFromZeroPosition, 0, 0, abs(Row2Reg-Row1Reg), abs(Column2Reg-Column1Reg))</l>
<c>    *</c>
<l>        smallest_rectangle1 (h_regRegionFront, Row1Reg, Column1Reg, Row2Reg, Column2Reg)</l>
<l>    gen_rectangle1 (h_regRegionFrontMmFromZeroPosition, 0, 0, abs(Column2Reg-Column1Reg), abs(Row2Reg-Row1Reg))</l>
<c>    *</c>
<l>        smallest_rectangle1 (h_regRegionBottom, Row1Reg, Column1Reg, Row2Reg, Column2Reg)</l>
<l>    gen_rectangle1 (h_regRegionBottomMmFromZeroPosition, 0, 0, abs(Column2Reg-Column1Reg), abs(Row2Reg-Row1Reg))</l>
<c>    *</c>
<l>        smallest_rectangle1 (h_regRegionBack, Row1Reg, Column1Reg, Row2Reg, Column2Reg)</l>
<l>    gen_rectangle1 (h_regRegionBackMmFromZeroPosition, 0, 0, abs(Column2Reg-Column1Reg), abs(Row2Reg-Row1Reg))</l>
<c>    *</c>
<l>        smallest_rectangle1 (h_regRegionTop, Row1Reg, Column1Reg, Row2Reg, Column2Reg)</l>
<l>    gen_rectangle1 (h_regRegionTopMmFromZeroPosition, 0, 0, abs(Column2Reg-Column1Reg), abs(Row2Reg-Row1Reg))</l>
<c>    *</c>
<l>        smallest_rectangle1 (h_regRegionLeft, Row1Reg, Column1Reg, Row2Reg, Column2Reg)</l>
<l>    gen_rectangle1 (h_regRegionLeftMmFromZeroPosition, 0, 0, abs(Row2Reg-Row1Reg), abs(Column2Reg-Column1Reg))</l>
<c>    *</c>
<l>catch (h_mix_arrException)</l>
<c>    </c>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="Function_A0670_PlacementRegionsToZeroPosition">
<parameters>
<parameter id="h_mix_arrException"/>
<parameter id="h_regRegionBack"/>
<parameter id="h_regRegionBackMmFromZeroPosition"/>
<parameter id="h_regRegionBottom"/>
<parameter id="h_regRegionBottomMmFromZeroPosition"/>
<parameter id="h_regRegionFront"/>
<parameter id="h_regRegionFrontMmFromZeroPosition"/>
<parameter id="h_regRegionLeft"/>
<parameter id="h_regRegionLeftMmFromZeroPosition"/>
<parameter id="h_regRegionRight"/>
<parameter id="h_regRegionRightMmFromZeroPosition"/>
<parameter id="h_regRegionTop"/>
<parameter id="h_regRegionTopMmFromZeroPosition"/>
</parameters>
</docu>
</procedure>
<procedure name="Function_PlacementRegionsAndCirclesToZeroPosition">
<interface>
<io>
<par name="h_regRegionRight" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionRight" base_type="iconic" dimension="0"/>
<par name="h_regRegionFront" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionFront" base_type="iconic" dimension="0"/>
<par name="h_regRegionBottom" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBottom" base_type="iconic" dimension="0"/>
<par name="h_regRegionBack" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBack" base_type="iconic" dimension="0"/>
<par name="h_regRegionTop" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionTop" base_type="iconic" dimension="0"/>
<par name="h_regRegionLeft" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionLeft" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="h_regRegionRightMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionRightMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionFrontMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionFrontMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionBottomMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBottomMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionBackMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBackMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionTopMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionTopMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_regRegionLeftMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionLeftMmInZeroPosition" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="h_intOfflineImageProcessing" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="h_mix_arrException" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> **** Function_PlacementRegionsAndCirclesToZeroPosition    </c>
<l>    h_mix_arrException := []</l>
<l>    gen_empty_obj (h_regRegionRightMmInZeroPosition)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionRightMmInZeroPosition)</l>
<l>    gen_empty_obj (h_regRegionFrontMmInZeroPosition)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionFrontMmInZeroPosition)        </l>
<l>    gen_empty_obj (h_regRegionBottomMmInZeroPosition)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionBottomMmInZeroPosition)</l>
<l>    gen_empty_obj (h_regRegionBackMmInZeroPosition)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionBackMmInZeroPosition)       </l>
<l>    gen_empty_obj (h_regRegionTopMmInZeroPosition)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionTopMmInZeroPosition) </l>
<l>    gen_empty_obj (h_regRegionLeftMmInZeroPosition)</l>
<l>    gen_empty_obj (h_con_arrCirclesInRegionLeftMmInZeroPosition)     </l>
<c>    </c>
<l>try    </l>
<c>    * &gt;&gt; RegionRight, CirclesInRegionRight</c>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        gen_image_const (Image, 'byte', 3000, 3000)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (h_regRegionRight)</l>
<l>        dev_display (h_con_arrCirclesInRegionRight)</l>
<l>    endif</l>
<c>    * Najdenie stredu regionu </c>
<l>        smallest_rectangle2 (h_regRegionRight, RowC, ColumnC, Phi, Length1, Length2)</l>
<c>    * Mozno bude treba zrkadlovo otocit, uvidime podla pohladu kamery</c>
<l>        smallest_rectangle1 (h_regRegionRight, Row1, Column1, Row2, Column2)</l>
<c>    * Posunutie tak aby lavy horny roh bol v [0, 0], tak ako to vidi kamera </c>
<l>    ShiftUp   := -Row1</l>
<l>    ShiftLeft := -Column1   </l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, ShiftUp, ShiftLeft, HomMat2DTranslate)</l>
<l>        affine_trans_region (h_regRegionRight, RegionAffineTransRegionToZeroPoint, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>        affine_trans_contour_xld (h_con_arrCirclesInRegionRight, ContoursAffineTransCirclesToZeroPoint, HomMat2DTranslate)</l>
<l>    if (h_intOfflineImageProcessing)    </l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegionToZeroPoint)       </l>
<l>        dev_display (ContoursAffineTransCirclesToZeroPoint) </l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(45))</l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(0))</l>
<l>    endif</l>
<l>    h_regRegionRightMmInZeroPosition              := RegionAffineTransRegionToZeroPoint</l>
<l>    h_con_arrCirclesInRegionRightMmInZeroPosition := ContoursAffineTransCirclesToZeroPoint</l>
<c>    * &lt;&lt; RegionRight, CirclesInRegionRight    </c>
<c></c>
<c>    * &gt;&gt; RegionFront, CirclesInRegionFront</c>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>            dev_display (h_regRegionFront)</l>
<l>            dev_display (h_con_arrCirclesInRegionFront)</l>
<l>    endif</l>
<c>    * Najdenie stredu regionu </c>
<l>        smallest_rectangle2 (h_regRegionFront, RowC, ColumnC, Phi, Length1, Length2)</l>
<c>    * Zrotovanie okolo stredu regionu, tak ako to bude vidiet kamera </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(-90), RowC, ColumnC, HomMat2DRotate) </l>
<l>        affine_trans_region (h_regRegionFront, RegionAffineTransRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<l>        affine_trans_contour_xld (h_con_arrCirclesInRegionFront, ContoursAffineTransCircles, HomMat2DRotate)</l>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegion)       </l>
<l>        dev_display (ContoursAffineTransCircles)   </l>
<l>    endif</l>
<c>    * Najdenie suradnic zrotovaneho regionu    </c>
<l>    smallest_rectangle1 (RegionAffineTransRegion, Row1, Column1, Row2, Column2)</l>
<c>    * Posunutie tak aby lavy horny roh bol v [0, 0], tak ako to vidi kamera </c>
<l>    ShiftUp   := -Row1</l>
<l>    ShiftLeft := -Column1   </l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, ShiftUp, ShiftLeft, HomMat2DTranslate)</l>
<l>    affine_trans_region (RegionAffineTransRegion, RegionAffineTransRegionToZeroPoint, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    affine_trans_contour_xld (ContoursAffineTransCircles, ContoursAffineTransCirclesToZeroPoint, HomMat2DTranslate)      </l>
<l>    if (h_intOfflineImageProcessing)    </l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegionToZeroPoint)       </l>
<l>        dev_display (ContoursAffineTransCirclesToZeroPoint) </l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(45))</l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(0))</l>
<l>    endif</l>
<l>    h_regRegionFrontMmInZeroPosition              := RegionAffineTransRegionToZeroPoint</l>
<l>    h_con_arrCirclesInRegionFrontMmInZeroPosition := ContoursAffineTransCirclesToZeroPoint</l>
<c>    * &lt;&lt; RegionFront, CirclesInRegionFront    </c>
<c>        </c>
<c>    * &gt;&gt; RegionBottom, CirclesInRegionBottom</c>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>            dev_display (h_regRegionBottom)</l>
<l>            dev_display (h_con_arrCirclesInRegionBottom)</l>
<l>    endif</l>
<c>    * Najdenie stredu regionu </c>
<l>        smallest_rectangle2 (h_regRegionBottom, RowC, ColumnC, Phi, Length1, Length2)</l>
<c>    * Zrotovanie okolo stredu regionu, tak ako to bude vidiet kamera </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(-90), RowC, ColumnC, HomMat2DRotate) </l>
<l>        affine_trans_region (h_regRegionBottom, RegionAffineTransRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<l>        affine_trans_contour_xld (h_con_arrCirclesInRegionBottom, ContoursAffineTransCircles, HomMat2DRotate)</l>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegion)       </l>
<l>        dev_display (ContoursAffineTransCircles)   </l>
<l>    endif</l>
<c>    * Najdenie suradnic zrotovaneho regionu    </c>
<l>    smallest_rectangle1 (RegionAffineTransRegion, Row1, Column1, Row2, Column2)</l>
<c>    * Posunutie tak aby lavy horny roh bol v [0, 0], tak ako to vidi kamera </c>
<l>    ShiftUp   := -Row1</l>
<l>    ShiftLeft := -Column1   </l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, ShiftUp, ShiftLeft, HomMat2DTranslate)</l>
<l>    affine_trans_region (RegionAffineTransRegion, RegionAffineTransRegionToZeroPoint, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    affine_trans_contour_xld (ContoursAffineTransCircles, ContoursAffineTransCirclesToZeroPoint, HomMat2DTranslate)      </l>
<l>    if (h_intOfflineImageProcessing)    </l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegionToZeroPoint)       </l>
<l>        dev_display (ContoursAffineTransCirclesToZeroPoint) </l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(45))</l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(0))</l>
<l>    endif</l>
<l>    h_regRegionBottomMmInZeroPosition              := RegionAffineTransRegionToZeroPoint</l>
<l>    h_con_arrCirclesInRegionBottomMmInZeroPosition := ContoursAffineTransCirclesToZeroPoint</l>
<c>    * &lt;&lt; RegionBottom, CirclesInRegionBottom</c>
<c>    </c>
<c>    * &gt;&gt; RegionBack, CirclesInRegionBack</c>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>            dev_display (h_regRegionBack)</l>
<l>            dev_display (h_con_arrCirclesInRegionBack)</l>
<l>    endif</l>
<c>    * Najdenie stredu regionu </c>
<l>        smallest_rectangle2 (h_regRegionBack, RowC, ColumnC, Phi, Length1, Length2)</l>
<c>    * Zrotovanie okolo stredu regionu, tak ako to bude vidiet kamera </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(-90), RowC, ColumnC, HomMat2DRotate) </l>
<l>        affine_trans_region (h_regRegionBack, RegionAffineTransRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<l>        affine_trans_contour_xld (h_con_arrCirclesInRegionBack, ContoursAffineTransCircles, HomMat2DRotate)</l>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegion)       </l>
<l>        dev_display (ContoursAffineTransCircles)   </l>
<l>    endif</l>
<c>    * Najdenie suradnic zrotovaneho regionu    </c>
<l>    smallest_rectangle1 (RegionAffineTransRegion, Row1, Column1, Row2, Column2)</l>
<c>    * Posunutie tak aby lavy horny roh bol v [0, 0], tak ako to vidi kamera </c>
<l>    ShiftUp   := -Row1</l>
<l>    ShiftLeft := -Column1   </l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, ShiftUp, ShiftLeft, HomMat2DTranslate)</l>
<l>    affine_trans_region (RegionAffineTransRegion, RegionAffineTransRegionToZeroPoint, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    affine_trans_contour_xld (ContoursAffineTransCircles, ContoursAffineTransCirclesToZeroPoint, HomMat2DTranslate)      </l>
<l>    if (h_intOfflineImageProcessing)    </l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegionToZeroPoint)       </l>
<l>        dev_display (ContoursAffineTransCirclesToZeroPoint) </l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(45))</l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(0))</l>
<l>    endif</l>
<l>    h_regRegionBackMmInZeroPosition              := RegionAffineTransRegionToZeroPoint</l>
<l>    h_con_arrCirclesInRegionBackMmInZeroPosition := ContoursAffineTransCirclesToZeroPoint</l>
<c>    * &lt;&lt; RegionBack, CirclesInRegionBack     </c>
<c>    </c>
<c>    * &gt;&gt; RegionTop, CirclesInRegionTop</c>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>            dev_display (h_regRegionTop)</l>
<l>            dev_display (h_con_arrCirclesInRegionTop)</l>
<l>    endif</l>
<c>    * Najdenie stredu regionu </c>
<l>        smallest_rectangle2 (h_regRegionTop, RowC, ColumnC, Phi, Length1, Length2)</l>
<c>    * Zrotovanie okolo stredu regionu, tak ako to bude vidiet kamera </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(-90), RowC, ColumnC, HomMat2DRotate) </l>
<l>        affine_trans_region (h_regRegionTop, RegionAffineTransRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<l>        affine_trans_contour_xld (h_con_arrCirclesInRegionTop, ContoursAffineTransCircles, HomMat2DRotate)</l>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegion)       </l>
<l>        dev_display (ContoursAffineTransCircles)   </l>
<l>    endif</l>
<c>    * Najdenie suradnic zrotovaneho regionu    </c>
<l>    smallest_rectangle1 (RegionAffineTransRegion, Row1, Column1, Row2, Column2)</l>
<c>    * Posunutie tak aby lavy horny roh bol v [0, 0], tak ako to vidi kamera </c>
<l>    ShiftUp   := -Row1</l>
<l>    ShiftLeft := -Column1   </l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, ShiftUp, ShiftLeft, HomMat2DTranslate)</l>
<l>    affine_trans_region (RegionAffineTransRegion, RegionAffineTransRegionToZeroPoint, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    affine_trans_contour_xld (ContoursAffineTransCircles, ContoursAffineTransCirclesToZeroPoint, HomMat2DTranslate)      </l>
<l>    if (h_intOfflineImageProcessing)    </l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegionToZeroPoint)       </l>
<l>        dev_display (ContoursAffineTransCirclesToZeroPoint) </l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(45))</l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(0))</l>
<l>    endif</l>
<l>    h_regRegionTopMmInZeroPosition              := RegionAffineTransRegionToZeroPoint</l>
<l>    h_con_arrCirclesInRegionTopMmInZeroPosition := ContoursAffineTransCirclesToZeroPoint</l>
<c>    * &lt;&lt; RegionTop, CirclesInRegionTop</c>
<c>    </c>
<c>    * &gt;&gt; RegionLeft, CirclesInRegionLeft</c>
<l>    if (h_intOfflineImageProcessing)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>            dev_display (h_regRegionLeft)</l>
<l>            dev_display (h_con_arrCirclesInRegionLeft)</l>
<l>    endif</l>
<c>    * Najdenie stredu regionu </c>
<l>        smallest_rectangle2 (h_regRegionLeft, RowC, ColumnC, Phi, Length1, Length2)</l>
<c>    * Mozno bude treba zrkadlovo otocit, uvidime podla pohladu kamery</c>
<l>        smallest_rectangle1 (h_regRegionLeft, Row1, Column1, Row2, Column2)</l>
<c>    * Posunutie tak aby lavy horny roh bol v [0, 0], tak ako to vidi kamera </c>
<l>    ShiftUp   := -Row1</l>
<l>    ShiftLeft := -Column1   </l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, ShiftUp, ShiftLeft, HomMat2DTranslate)</l>
<l>        affine_trans_region (h_regRegionLeft, RegionAffineTransRegionToZeroPoint, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>        affine_trans_contour_xld (h_con_arrCirclesInRegionLeft, ContoursAffineTransCirclesToZeroPoint, HomMat2DTranslate)</l>
<l>    if (h_intOfflineImageProcessing)    </l>
<l>        dev_clear_window ()</l>
<l>        dev_display (Image)</l>
<l>        dev_display (RegionAffineTransRegionToZeroPoint)       </l>
<l>        dev_display (ContoursAffineTransCirclesToZeroPoint) </l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(45))</l>
<l>        gen_cross_contour_xld (CrossZero, 0, 0, 20, rad(0))</l>
<l>    endif</l>
<l>    h_regRegionLeftMmInZeroPosition              := RegionAffineTransRegionToZeroPoint</l>
<l>    h_con_arrCirclesInRegionLeftMmInZeroPosition := ContoursAffineTransCirclesToZeroPoint</l>
<c>    * &lt;&lt; RegionLeft, CirclesInRegionLeft   </c>
<c>    </c>
<c>       </c>
<l>catch (h_mix_arrException)</l>
<c>    </c>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="Function_PlacementRegionsAndCirclesToZeroPosition">
<parameters>
<parameter id="h_con_arrCirclesInRegionBack"/>
<parameter id="h_con_arrCirclesInRegionBackMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionBottom"/>
<parameter id="h_con_arrCirclesInRegionBottomMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionFront"/>
<parameter id="h_con_arrCirclesInRegionFrontMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionLeft"/>
<parameter id="h_con_arrCirclesInRegionLeftMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionRight"/>
<parameter id="h_con_arrCirclesInRegionRightMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionTop"/>
<parameter id="h_con_arrCirclesInRegionTopMmInZeroPosition"/>
<parameter id="h_intOfflineImageProcessing"/>
<parameter id="h_mix_arrException"/>
<parameter id="h_regRegionBack"/>
<parameter id="h_regRegionBackMmInZeroPosition"/>
<parameter id="h_regRegionBottom"/>
<parameter id="h_regRegionBottomMmInZeroPosition"/>
<parameter id="h_regRegionFront"/>
<parameter id="h_regRegionFrontMmInZeroPosition"/>
<parameter id="h_regRegionLeft"/>
<parameter id="h_regRegionLeftMmInZeroPosition"/>
<parameter id="h_regRegionRight"/>
<parameter id="h_regRegionRightMmInZeroPosition"/>
<parameter id="h_regRegionTop"/>
<parameter id="h_regRegionTopMmInZeroPosition"/>
</parameters>
</docu>
</procedure>
<procedure name="Function_MeasurementCirclesCoordinations">
<interface>
<io>
<par name="h_con_arrCirclesInRegionRightMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionFrontMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBottomMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionBackMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionTopMmInZeroPosition" base_type="iconic" dimension="0"/>
<par name="h_con_arrCirclesInRegionLeftMmInZeroPosition" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="h_real_arrXPositionMmRightFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmRightFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmRightFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmFrontFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmFrontFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmFrontFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmBottomFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmBottomFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmBottomFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmBackFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmBackFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmBackFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmTopFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmTopFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmTopFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmLeftFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmLeftFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmLeftFromDrawing" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> **** Function_MeasurementCircleCoordinations  </c>
<c> </c>
<l>h_real_arrXPositionMmRightFromDrawing := []</l>
<l>h_real_arrYPositionMmRightFromDrawing := []</l>
<l>h_real_arrDiameterMmRightFromDrawing := []</l>
<l>h_real_arrXPositionMmFrontFromDrawing := []</l>
<l>h_real_arrYPositionMmFrontFromDrawing := []</l>
<l>h_real_arrDiameterMmFrontFromDrawing := []</l>
<l>h_real_arrXPositionMmBottomFromDrawing := []</l>
<l>h_real_arrYPositionMmBottomFromDrawing := []</l>
<l>h_real_arrDiameterMmBottomFromDrawing := []</l>
<l>h_real_arrXPositionMmBackFromDrawing := []</l>
<l>h_real_arrYPositionMmBackFromDrawing := []</l>
<l>h_real_arrDiameterMmBackFromDrawing := []</l>
<l>h_real_arrXPositionMmTopFromDrawing := []</l>
<l>h_real_arrYPositionMmTopFromDrawing := []</l>
<l>h_real_arrDiameterMmTopFromDrawing := []</l>
<l>h_real_arrXPositionMmLeftFromDrawing := []</l>
<l>h_real_arrYPositionMmLeftFromDrawing := []</l>
<l>h_real_arrDiameterMmLeftFromDrawing := []</l>
<c> </c>
<l> for Index := 0 to 5 by 1</l>
<l>    if (Index = 0)</l>
<l>        Region := h_con_arrCirclesInRegionRightMmInZeroPosition</l>
<l>    elseif (Index = 1)</l>
<l>        Region := h_con_arrCirclesInRegionFrontMmInZeroPosition</l>
<l>    elseif (Index = 2)</l>
<l>        Region := h_con_arrCirclesInRegionBottomMmInZeroPosition</l>
<l>    elseif (Index = 3)</l>
<l>        Region := h_con_arrCirclesInRegionBackMmInZeroPosition</l>
<l>    elseif (Index = 4)</l>
<l>        Region := h_con_arrCirclesInRegionTopMmInZeroPosition</l>
<l>    elseif (Index = 5)</l>
<l>        Region := h_con_arrCirclesInRegionLeftMmInZeroPosition</l>
<l>    endif</l>
<c></c>
<l>    select_contours_xld (Region, SelectedContours, 'closed', 0, 0.1, -0.5, 0.5)</l>
<l>    count_obj(SelectedContours,NumberOfContours)</l>
<l>  if (NumberOfContours &gt; 0)</l>
<l>    select_contours_xld (SelectedContours, SelectedContours1, 'contour_length', 2, 200, -0.5, 0.5)</l>
<l>    fit_circle_contour_xld(SelectedContours1, 'algebraic', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>    gen_region_contour_xld (SelectedContours1, Region, 'filled')</l>
<l>    tuple_sort_index(Row, Indices)</l>
<l>    tuple_select(Row, Indices, SelectedXPosition)</l>
<l>    tuple_select(Column, Indices, SelectedYPosition)</l>
<l>    tuple_select(Radius, Indices, SelectedRadius)</l>
<c>    </c>
<l>     gen_cross_contour_xld (Cross, SelectedXPosition, SelectedYPosition, 16, 0.785398)</l>
<l>*     tuple_sqrt ((Area/3.14159), Sqrt)</l>
<l>    SelectedDiameter :=2*SelectedRadius</l>
<l>    dev_display (Cross)</l>
<l>    dev_clear_window()</l>
<c>    </c>
<l>    dev_display (Region)</l>
<l>    dev_display (Cross)</l>
<c>    </c>
<l>    for i := 0 to |Row| - 1 by 1</l>
<c>        </c>
<l>        dev_disp_text('Row ' + SelectedXPosition[i], 'window', SelectedXPosition[i], SelectedYPosition[i], 'white', ['box', 'shadow'], [false, false])</l>
<l>        dev_disp_text('Column ' + SelectedYPosition[i], 'window', SelectedXPosition[i] + 15, SelectedYPosition[i], 'white', ['box', 'shadow'], [false, false])</l>
<l>        dev_disp_text('Diameter ' + SelectedDiameter[i], 'window', SelectedXPosition[i] + 25, SelectedYPosition[i], 'white', ['box', 'shadow'], [false, false])</l>
<l>    endfor</l>
<c>    </c>
<l>    if (Index = 0)</l>
<l>        h_real_arrXPositionMmRightFromDrawing := SelectedXPosition</l>
<l>        h_real_arrYPositionMmRightFromDrawing := SelectedYPosition</l>
<l>        h_real_arrDiameterMmRightFromDrawing := SelectedDiameter</l>
<l>    elseif (Index = 1)</l>
<l>        h_real_arrXPositionMmFrontFromDrawing := SelectedXPosition</l>
<l>        h_real_arrYPositionMmFrontFromDrawing := SelectedYPosition</l>
<l>        h_real_arrDiameterMmFrontFromDrawing := SelectedDiameter</l>
<l>    elseif (Index = 2)</l>
<l>        h_real_arrXPositionMmBottomFromDrawing := SelectedXPosition</l>
<l>        h_real_arrYPositionMmBottomFromDrawing := SelectedYPosition</l>
<l>        h_real_arrDiameterMmBottomFromDrawing := SelectedDiameter</l>
<l>    elseif (Index = 3)</l>
<l>        h_real_arrXPositionMmBackFromDrawing := SelectedXPosition</l>
<l>        h_real_arrYPositionMmBackFromDrawing := SelectedYPosition</l>
<l>        h_real_arrDiameterMmBackFromDrawing := SelectedDiameter</l>
<l>    elseif (Index = 4)</l>
<l>        h_real_arrXPositionMmTopFromDrawing := SelectedXPosition</l>
<l>        h_real_arrYPositionMmTopFromDrawing := SelectedYPosition</l>
<l>        h_real_arrDiameterMmTopFromDrawing := SelectedDiameter</l>
<l>    elseif (Index = 5)</l>
<l>        h_real_arrXPositionMmLeftFromDrawing := SelectedXPosition</l>
<l>        h_real_arrYPositionMmLeftFromDrawing := SelectedYPosition</l>
<l>        h_real_arrDiameterMmLeftFromDrawing := SelectedDiameter   </l>
<l>    endif </l>
<l>  endif </l>
<l>endfor    </l>
<l>return ()</l>
</body>
<docu id="Function_MeasurementCirclesCoordinations">
<parameters>
<parameter id="h_con_arrCirclesInRegionBackMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionBottomMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionFrontMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionLeftMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionRightMmInZeroPosition"/>
<parameter id="h_con_arrCirclesInRegionTopMmInZeroPosition"/>
<parameter id="h_real_arrDiameterMmBackFromDrawing"/>
<parameter id="h_real_arrDiameterMmBottomFromDrawing"/>
<parameter id="h_real_arrDiameterMmFrontFromDrawing"/>
<parameter id="h_real_arrDiameterMmLeftFromDrawing"/>
<parameter id="h_real_arrDiameterMmRightFromDrawing"/>
<parameter id="h_real_arrDiameterMmTopFromDrawing"/>
<parameter id="h_real_arrXPositionMmBackFromDrawing"/>
<parameter id="h_real_arrXPositionMmBottomFromDrawing"/>
<parameter id="h_real_arrXPositionMmFrontFromDrawing"/>
<parameter id="h_real_arrXPositionMmLeftFromDrawing"/>
<parameter id="h_real_arrXPositionMmRightFromDrawing"/>
<parameter id="h_real_arrXPositionMmTopFromDrawing"/>
<parameter id="h_real_arrYPositionMmBackFromDrawing"/>
<parameter id="h_real_arrYPositionMmBottomFromDrawing"/>
<parameter id="h_real_arrYPositionMmFrontFromDrawing"/>
<parameter id="h_real_arrYPositionMmLeftFromDrawing"/>
<parameter id="h_real_arrYPositionMmRightFromDrawing"/>
<parameter id="h_real_arrYPositionMmTopFromDrawing"/>
</parameters>
</docu>
</procedure>
<procedure name="Function_RoiGenerator">
<interface>
<io>
<par name="CirclesInRegionRight" base_type="iconic" dimension="0"/>
<par name="CirclesInRegionFront" base_type="iconic" dimension="0"/>
<par name="CirclesInRegionBottom" base_type="iconic" dimension="0"/>
<par name="CirclesInRegionBack" base_type="iconic" dimension="0"/>
<par name="CirclesInRegionTop" base_type="iconic" dimension="0"/>
<par name="CirclesInRegionLeft" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="h_reg_arrRoiMmTopPartSmallHolesForLsCameras" base_type="iconic" dimension="0"/>
<par name="h_reg_arrRoiMmTopPartLargeHolesForArCameras" base_type="iconic" dimension="0"/>
<par name="h_reg_arrRoiMmBottomPartSmallHolesForLsCameras" base_type="iconic" dimension="0"/>
<par name="h_reg_arrRoiMmBottomPartLargeHolesForArCameras" base_type="iconic" dimension="0"/>
<par name="h_reg_arrRoiMmLeftPartHolesForLsCameras" base_type="iconic" dimension="0"/>
<par name="h_reg_arrRoiMmRightPartHolesForLsCameras" base_type="iconic" dimension="0"/>
<par name="h_reg_arrRoiMmFrontPartHolesForArCameras" base_type="iconic" dimension="0"/>
<par name="h_reg_arrRoiMmBackPartHolesForArCameras" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="h_real_arrXPositionMmRightFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmRightFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmRightFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmFrontFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmFrontFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmFrontFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmBottomFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmBottomFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmBottomFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmBackFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmBackFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmBackFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmTopFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmTopFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmTopFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrXPositionMmLeftFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrYPositionMmLeftFromDrawing" base_type="ctrl" dimension="0"/>
<par name="h_real_arrDiameterMmLeftFromDrawing" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c> **** Function_RoiGenerator  </c>
<c>     </c>
<c>* Vyhladavacie regiony maju vacsi priemer nez priemery otvorov </c>
<c>* Limit priemeru dier v mm, nad limit velke diery, pod limit male diery</c>
<l>limit := 10</l>
<c>* Rozsirenie vyhladavacieho regionu v mm</c>
<l>enlarge := 6</l>
<l>gen_empty_region(h_reg_arrRoiMmTopPartSmallHolesForLsCameras)</l>
<l>gen_empty_region(h_reg_arrRoiMmTopPartLargeHolesForArCameras)</l>
<l>gen_empty_region(h_reg_arrRoiMmBottomPartSmallHolesForLsCameras)</l>
<l>gen_empty_region(h_reg_arrRoiMmBottomPartLargeHolesForArCameras)</l>
<l>gen_empty_region(h_reg_arrRoiMmLeftPartHolesForLsCameras)</l>
<l>gen_empty_region(h_reg_arrRoiMmRightPartHolesForLsCameras)</l>
<l>gen_empty_region(h_reg_arrRoiMmFrontPartHolesForArCameras)</l>
<l>gen_empty_region(h_reg_arrRoiMmBackPartHolesForArCameras)</l>
<c></c>
<l>for Index := 0 to 5 by 1</l>
<l>    if (Index = 0)</l>
<l>        Region := CirclesInRegionRight</l>
<l>        XPositionMmFromDrawing := h_real_arrXPositionMmRightFromDrawing</l>
<l>        YPositionMmFromDrawing := h_real_arrYPositionMmRightFromDrawing</l>
<l>        DiameterMmFromDrawing := h_real_arrDiameterMmRightFromDrawing</l>
<l>        RoiForCamerasSmall := h_reg_arrRoiMmRightPartHolesForLsCameras</l>
<l>    elseif (Index = 1)</l>
<l>        Region := CirclesInRegionFront</l>
<l>        XPositionMmFromDrawing := h_real_arrXPositionMmFrontFromDrawing</l>
<l>        YPositionMmFromDrawing := h_real_arrYPositionMmFrontFromDrawing</l>
<l>        DiameterMmFromDrawing := h_real_arrDiameterMmFrontFromDrawing</l>
<l>        RoiForCamerasSmall := h_reg_arrRoiMmFrontPartHolesForArCameras</l>
<l>    elseif (Index = 2)</l>
<l>        Region := CirclesInRegionBottom</l>
<l>        XPositionMmFromDrawing := h_real_arrXPositionMmBottomFromDrawing</l>
<l>        YPositionMmFromDrawing := h_real_arrYPositionMmBottomFromDrawing</l>
<l>        DiameterMmFromDrawing := h_real_arrDiameterMmBottomFromDrawing</l>
<l>        RoiForCamerasSmall := h_reg_arrRoiMmBottomPartSmallHolesForLsCameras</l>
<l>        RoiForCamerasLarge := h_reg_arrRoiMmBottomPartLargeHolesForArCameras</l>
<l>    elseif (Index = 3)</l>
<l>        Region := CirclesInRegionBack</l>
<l>        XPositionMmFromDrawing := h_real_arrXPositionMmBackFromDrawing</l>
<l>        YPositionMmFromDrawing := h_real_arrYPositionMmBackFromDrawing</l>
<l>        DiameterMmFromDrawing := h_real_arrDiameterMmBackFromDrawing</l>
<l>        RoiForCamerasSmall := h_reg_arrRoiMmBackPartHolesForArCameras</l>
<l>    elseif (Index = 4)</l>
<l>        Region := CirclesInRegionTop</l>
<l>        XPositionMmFromDrawing := h_real_arrXPositionMmTopFromDrawing</l>
<l>        YPositionMmFromDrawing := h_real_arrYPositionMmTopFromDrawing</l>
<l>        DiameterMmFromDrawing := h_real_arrDiameterMmTopFromDrawing</l>
<l>        RoiForCamerasSmall := h_reg_arrRoiMmTopPartSmallHolesForLsCameras</l>
<l>        RoiForCamerasLarge := h_reg_arrRoiMmTopPartLargeHolesForArCameras</l>
<l>    elseif (Index = 5)</l>
<l>        Region := CirclesInRegionLeft</l>
<l>        XPositionMmFromDrawing := h_real_arrXPositionMmLeftFromDrawing</l>
<l>        YPositionMmFromDrawing := h_real_arrYPositionMmLeftFromDrawing</l>
<l>        DiameterMmFromDrawing := h_real_arrDiameterMmLeftFromDrawing</l>
<l>        RoiForCamerasSmall := h_reg_arrRoiMmLeftPartHolesForLsCameras</l>
<l>    endif</l>
<c></c>
<l>    count_obj(Region, NumberOfCircless)</l>
<l>    for I := 0 to NumberOfCircless-1 by 1</l>
<l>        tuple_select(XPositionMmFromDrawing, I, SelectedX)</l>
<l>        tuple_select(YPositionMmFromDrawing, I, SelectedY)</l>
<l>        tuple_select(DiameterMmFromDrawing, I, SelectedDiameter)    </l>
<l>        if (SelectedDiameter &gt; limit)</l>
<l>            gen_rectangle1(Rectangle1, (SelectedX-SelectedDiameter/2)-enlarge, (SelectedY-SelectedDiameter/2)-enlarge, (SelectedDiameter/2+SelectedX)+enlarge, (SelectedDiameter/2+SelectedY)+enlarge)</l>
<l>            clip_region(Rectangle1, RegionClipped, (SelectedDiameter/2-SelectedX)-enlarge, (SelectedDiameter/2-SelectedY)-enlarge, (SelectedDiameter/2+SelectedX)+enlarge, (SelectedDiameter/2+SelectedY)+enlarge)</l>
<l>            concat_obj(RoiForCamerasLarge, RegionClipped, RoiForCamerasLarge)   </l>
<l>        else</l>
<l>            gen_rectangle1(Rectangle1, (SelectedX-SelectedDiameter/2)-enlarge, (SelectedY-SelectedDiameter/2)-enlarge, (SelectedDiameter/2+SelectedX)+enlarge, (SelectedDiameter/2+SelectedY)+enlarge)</l>
<l>            clip_region(Rectangle1, RegionClipped, (SelectedDiameter/2-SelectedX)-enlarge, (SelectedDiameter/2-SelectedY)-enlarge, (SelectedDiameter/2+SelectedX)+enlarge, (SelectedDiameter/2+SelectedY)+enlarge)</l>
<l>            concat_obj(RoiForCamerasSmall, RegionClipped, RoiForCamerasSmall)</l>
<l>        endif</l>
<c></c>
<l>    endfor</l>
<c></c>
<l>    if (Index = 0)</l>
<l>        h_reg_arrRoiMmRightPartHolesForLsCameras := RoiForCamerasSmall</l>
<l>    elseif (Index = 1)</l>
<l>        h_reg_arrRoiMmFrontPartHolesForArCameras := RoiForCamerasSmall</l>
<l>    elseif (Index = 2)</l>
<l>        h_reg_arrRoiMmBottomPartSmallHolesForLsCameras := RoiForCamerasSmall</l>
<l>        h_reg_arrRoiMmBottomPartLargeHolesForArCameras := RoiForCamerasLarge   </l>
<l>    elseif (Index = 3)</l>
<l>        h_reg_arrRoiMmBackPartHolesForArCameras := RoiForCamerasSmall</l>
<l>    elseif (Index = 4)</l>
<l>        h_reg_arrRoiMmTopPartSmallHolesForLsCameras := RoiForCamerasSmall</l>
<l>        h_reg_arrRoiMmTopPartLargeHolesForArCameras := RoiForCamerasLarge</l>
<l>    elseif (Index = 5)</l>
<l>        h_reg_arrRoiMmLeftPartHolesForLsCameras := RoiForCamerasSmall</l>
<l>    endif </l>
<c></c>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="Function_RoiGenerator">
<parameters>
<parameter id="CirclesInRegionBack"/>
<parameter id="CirclesInRegionBottom"/>
<parameter id="CirclesInRegionFront"/>
<parameter id="CirclesInRegionLeft"/>
<parameter id="CirclesInRegionRight"/>
<parameter id="CirclesInRegionTop"/>
<parameter id="h_real_arrDiameterMmBackFromDrawing"/>
<parameter id="h_real_arrDiameterMmBottomFromDrawing"/>
<parameter id="h_real_arrDiameterMmFrontFromDrawing"/>
<parameter id="h_real_arrDiameterMmLeftFromDrawing"/>
<parameter id="h_real_arrDiameterMmRightFromDrawing"/>
<parameter id="h_real_arrDiameterMmTopFromDrawing"/>
<parameter id="h_real_arrXPositionMmBackFromDrawing"/>
<parameter id="h_real_arrXPositionMmBottomFromDrawing"/>
<parameter id="h_real_arrXPositionMmFrontFromDrawing"/>
<parameter id="h_real_arrXPositionMmLeftFromDrawing"/>
<parameter id="h_real_arrXPositionMmRightFromDrawing"/>
<parameter id="h_real_arrXPositionMmTopFromDrawing"/>
<parameter id="h_real_arrYPositionMmBackFromDrawing"/>
<parameter id="h_real_arrYPositionMmBottomFromDrawing"/>
<parameter id="h_real_arrYPositionMmFrontFromDrawing"/>
<parameter id="h_real_arrYPositionMmLeftFromDrawing"/>
<parameter id="h_real_arrYPositionMmRightFromDrawing"/>
<parameter id="h_real_arrYPositionMmTopFromDrawing"/>
<parameter id="h_reg_arrRoiMmBackPartHolesForArCameras"/>
<parameter id="h_reg_arrRoiMmBottomPartLargeHolesForArCameras"/>
<parameter id="h_reg_arrRoiMmBottomPartSmallHolesForLsCameras"/>
<parameter id="h_reg_arrRoiMmFrontPartHolesForArCameras"/>
<parameter id="h_reg_arrRoiMmLeftPartHolesForLsCameras"/>
<parameter id="h_reg_arrRoiMmRightPartHolesForLsCameras"/>
<parameter id="h_reg_arrRoiMmTopPartLargeHolesForArCameras"/>
<parameter id="h_reg_arrRoiMmTopPartSmallHolesForLsCameras"/>
</parameters>
</docu>
</procedure>
</hdevelop>
